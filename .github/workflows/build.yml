on:
  workflow_call:
    inputs:
      docker:
        required: false
        type: string
      host:
        required: true
        type: string
      if:
        description: 'Whether to run this job'
        required: false
        default: true
        type: boolean
      publish:
        required: false
        type: string
      setup:
        required: false
        type: string
      target:
        required: true
        type: string
jobs:
  reusable-build:
    if: ${{ inputs.if }}
    name: stable - ${{ inputs.target }} - python@3.12
    runs-on: ${{ inputs.host }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            .cargo-cache
            target/
          key: ${{ inputs.target }}-cargo-${{ inputs.host }}
      - name: Install zig
        uses: mlugg/setup-zig@v1
        if: ${{ inputs.target == 'armv7-unknown-linux-gnueabihf' }}
        with:
          version: 0.13.0
      - name: Setup toolchain
        run: ${{ inputs.setup }}
        if: ${{ inputs.setup }}
        shell: bash
      - name: Install Bindgen
        if: ${{ inputs.target != 'aarch64-pc-windows-msvc' }}
        run: |
          cargo install --force --locked bindgen-cli
      - name: Install nasm for i686-pc-windows-msvc
        uses: ilammy/setup-nasm@v1
        if: inputs.target == 'i686-pc-windows-msvc'
      - name: Setup x86 Python for i686-pc-windows-msvc
        if: ${{ inputs.target == 'i686-pc-windows-msvc' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          architecture: "x86"
      - name: Setup Python for cross-compilation
        if: ${{ inputs.target == 'aarch64-pc-windows-msvc' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          architecture: "x64"
          check-latest: true
      - name: Download ARM64 Python
        if: ${{ inputs.target == 'aarch64-pc-windows-msvc' }}
        shell: pwsh
        run: |
          $pythonUrl = "https://www.python.org/ftp/python/3.12.0/python-3.12.0-embed-arm64.zip"
          $outputPath = "python-arm64.zip"
          Invoke-WebRequest -Uri $pythonUrl -OutFile $outputPath
          Expand-Archive -Path $outputPath -DestinationPath "python-arm64" -Force
          $env:PYTHON_ARM64_ROOT = "$PWD\python-arm64"
          echo "PYTHON_ARM64_ROOT=$env:PYTHON_ARM64_ROOT" | Out-File -FilePath $env:GITHUB_ENV -Append
      - name: Install Visual Studio Build Tools
        if: ${{ inputs.target == 'aarch64-pc-windows-msvc' }}
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: arm64
          toolset: 14.3
          sdk: 10.0.22621.0
      - name: Debug ARM64 Environment
        if: ${{ inputs.target == 'aarch64-pc-windows-msvc' }}
        shell: pwsh
        run: |
          Write-Host "=== System Architecture ==="
          Write-Host "Processor:"
          Get-WmiObject Win32_Processor | Select-Object Name, Architecture
          Write-Host "OS Architecture:"
          (Get-WmiObject Win32_OperatingSystem).OSArchitecture
          
          Write-Host "`n=== Visual Studio Build Tools ==="
          Write-Host "VSWHERE location:"
          where.exe vswhere
          Write-Host "VS installation:"
          &"${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -prerelease -format json | ConvertFrom-Json | Select-Object installationPath, installationVersion
          
          Write-Host "`n=== ARM64 Tools ==="
          Write-Host "ARM64 compiler:"
          where.exe cl
          Write-Host "ARM64 linker:"
          where.exe link
          Write-Host "ARM64 SDK:"
          Get-ChildItem "${env:ProgramFiles(x86)}\Windows Kits\10\bin\10.0.22621.0\arm64" -ErrorAction SilentlyContinue
          
          Write-Host "`n=== Python ARM64 ==="
          Write-Host "Python architecture:"
          python -c "import platform; print(platform.machine())"
          Write-Host "Python DLL:"
          python -c "import sys; print(sys.dllhandle)"
          
          Write-Host "`n=== Environment Variables ==="
          Write-Host "INCLUDE: $env:INCLUDE"
          Write-Host "LIB: $env:LIB"
          Write-Host "LIBPATH: $env:LIBPATH"
          Write-Host "VCToolsVersion: $env:VCToolsVersion"
          Write-Host "WindowsSdkDir: $env:WindowsSdkDir"
          
          Write-Host "`n=== Rust ARM64 Support ==="
          Write-Host "Rustup targets:"
          rustup target list | findstr aarch64
          Write-Host "Rustc target:"
          rustc --print target-list | findstr aarch64
      - name: Setup Rust for ARM64 Windows
        if: ${{ inputs.target == 'aarch64-pc-windows-msvc' }}
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: aarch64-pc-windows-msvc
          components: rust-src, llvm-tools-preview
          override: true
      - name: Build and (Publish) aarch64-pc-windows-msvc
        if: ${{ inputs.target == 'aarch64-pc-windows-msvc' }}
        shell: pwsh
        run: |
          # Verify Rust installation
          rustc --version
          cargo --version
          
          # Create and activate virtual environment
          python -m venv .env
          .\.env\Scripts\Activate.ps1
          
          # Install requirements
          pip install -r requirements.txt
          pip install patchelf
          
          # Build or publish
          if ($env:SHOULD_PUBLISH -eq 'true') {
            Write-Output "~~~~ maturin publishing"
            maturin publish --no-sdist -u __token__ -p ${{ secrets.MATURIN_PASSWORD }}
          } else {
            Write-Output "~~~~ maturin building"
            maturin build
          }
      - name: Build and (Publish) x86_64-unknown-linux-musl
        uses: addnab/docker-run-action@v3
        if: ${{ inputs.target == 'x86_64-unknown-linux-musl' }}
        with:
          image: ${{ inputs.docker }}
          options: '-e SHOULD_PUBLISH=${{ inputs.publish }} --user 0:0 -v ${{ github.workspace }}/.cargo-cache/git/db:/usr/local/cargo/git/db -v ${{ github.workspace }}/.cargo/registry/cache:/usr/local/cargo/registry/cache -v ${{ github.workspace }}/.cargo/registry/index:/usr/local/cargo/registry/index -v ${{ github.workspace }}:/build -w /build'
          run: |
            pwd
            ls -lah
            whoami
            env
            echo "apk add:"
            apk add musl-dev gcc make cmake clang llvm build-base python3-dev
            export CARGO_BUILD_TARGET="x86_64-unknown-linux-musl"
            ln -s /usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/crtbeginS.o /usr/lib
            ln -s /usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/crtendS.o /usr/lib
            ln -s /usr/lib/gcc/x86_64-alpine-linux-musl/14.2.0/libgcc.a /usr/lib
            echo "apk update:"
            apk update
            rustup target add x86_64-unknown-linux-musl
            echo "create venv:"
            python3 -m venv .env
            . .env/bin/activate && pip install -r requirements.txt
            . .env/bin/activate && pip install patchelf
            if [ "${SHOULD_PUBLISH}" == 'true' ]; then
              echo "~~~~ maturin publishing"
              . .env/bin/activate && maturin publish --no-sdist -u __token__ -p ${{ secrets.MATURIN_PASSWORD }}
            else
              echo "~~~~ maturin building"
              . .env/bin/activate && maturin build
            fi
      - name: Build and (Publish) aarch64-unknown-linux-gnu
        uses: addnab/docker-run-action@v3
        if: ${{ inputs.target == 'aarch64-unknown-linux-gnu' }}
        with:
          image: ${{ inputs.docker }}
          options: '-e SHOULD_PUBLISH=${{ inputs.publish }} --user 0:0 -v ${{ github.workspace }}/.cargo-cache/git/db:/usr/local/cargo/git/db -v ${{ github.workspace }}/.cargo/registry/cache:/usr/local/cargo/registry/cache -v ${{ github.workspace }}/.cargo/registry/index:/usr/local/cargo/registry/index -v ${{ github.workspace }}:/build -w /build'
          run: |
            pwd
            ls -lah
            whoami
            env
            curl --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --profile minimal
            export PATH="$HOME/.cargo/bin:$PATH"
            # ring 0.17 assembly build needs __ARM_ARCH set
            export CFLAGS_aarch64_unknown_linux_gnu="-D__ARM_ARCH=8"
            rustup component add llvm-tools-preview || true
            rustup target add aarch64-unknown-linux-gnu
            python3 -m venv .env
            . .env/bin/activate && pip install -r requirements.txt
            . .env/bin/activate && pip install patchelf
            # this is in raw 'sh', use single '='
            if [ "${SHOULD_PUBLISH}" = 'true' ]; then
              echo "~~~~ maturin publishing"
              # pass '--debug' to avoid optimization, which breaks tls signature validation on this platform
              . .env/bin/activate && maturin publish --target ${{ inputs.target }} --no-sdist --debug -u __token__ -p ${{ secrets.MATURIN_PASSWORD }}
            else
              echo "~~~~ maturin building"
              . .env/bin/activate && maturin build --target ${{ inputs.target }}
            fi
      - name: Build Python Extension Module (non-docker)
        if: ${{ inputs.publish != true && !inputs.docker && !contains(inputs.target,'android') }}
        uses: PyO3/maturin-action@v1
        with:
          maturin-version: v1.6.0
          target: ${{ inputs.target }}
          # builds in release mode with the specified python version as the interpreter and the Cargo.toml file as the manifest
          args: --release -i python3.12 --target ${{ inputs.target }} -m Cargo.toml
      - name: Publish to PyPI (non-docker)
        if: ${{ inputs.publish == true && !inputs.docker && !contains(inputs.target,'android') }}
        uses: PyO3/maturin-action@v1
        with:
          command: publish
          maturin-version: v1.6.0
          target: ${{ inputs.target }}
          args: --no-sdist -i python3.12 -m Cargo.toml -u __token__ -p ${{ secrets.MATURIN_PASSWORD }}
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: bindings-${{ inputs.target }}
          path: target/wheels/*.whl # path to the python wheel package
          if-no-files-found: error
